<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>5. biPOD Supplementary Materials and Methods • biPOD</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="5. biPOD Supplementary Materials and Methods">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">biPOD</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/biPOD.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/a1_introduction.html">1. Introduction</a></li>
    <li><a class="dropdown-item" href="../articles/a2_task1.html">2. Task 1</a></li>
    <li><a class="dropdown-item" href="../articles/a3_task2.html">3. Task 0</a></li>
    <li><a class="dropdown-item" href="../articles/a4_task3.html">4. Task 3</a></li>
    <li><a class="dropdown-item" href="../articles/a5_supplementary_materials.html">5. biPOD Supplementary Materials and Methods</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>5. biPOD Supplementary Materials and Methods</h1>
            
      

      <div class="d-none name"><code>a5_supplementary_materials.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="methods">Methods<a class="anchor" aria-label="anchor" href="#methods"></a>
</h2>
<div class="section level3">
<h3 id="multi-step-logistic-and-exponential-growth-models">Multi-step logistic and exponential growth models<a class="anchor" aria-label="anchor" href="#multi-step-logistic-and-exponential-growth-models"></a>
</h3>
<p>A general growth process can be seen as a continuous-time Markov
process [8,11], where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y(x) \in \mathbb{N}_0</annotation></semantics></math>
represents the number of individuals in the population of cancerous cell
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
indicates the instant of time in which the first cancerous cell is born,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>=</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y(x=t_0)=1</annotation></semantics></math>.
The transition rates for such problem are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>α</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>lim</mo><mrow><mi>h</mi><mo>→</mo><msup><mn>0</mn><mo>+</mo></msup></mrow></munder><mfrac><mn>1</mn><mi>h</mi></mfrac><mi>P</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>∣</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>β</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>lim</mo><mrow><mi>h</mi><mo>→</mo><msup><mn>0</mn><mo>+</mo></msup></mrow></munder><mfrac><mn>1</mn><mi>h</mi></mfrac><mi>P</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>∣</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \alpha_n(x) = \lim_{h \rightarrow 0^+} \frac{1}{h} P[y(x+h) = n+1 \mid y(x)=n]\\
    \beta_n(x) = \lim_{h \rightarrow 0^+} \frac{1}{h} P[y(x+h) = n-1 \mid y(x)=n]
\end{align*}</annotation></semantics></math></p>
<p>Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha_n(t)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_n(t)</annotation></semantics></math>
are both positive functions and indicates the birth and death rates of
the population when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">y(x)=n</annotation></semantics></math>.
Similarly, one can denote with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\alpha(t)</annotation></semantics></math>
and with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta(t)</annotation></semantics></math>
the individual birth and death rate at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Assuming that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y(0)=n_0</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>∈</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">n_0 \in \mathbb{N}</annotation></semantics></math>
and given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∈</mo><msub><mi>ℕ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">m \in \mathbb{N}_0</annotation></semantics></math>,
one is interested in computing</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>P</mi><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>,</mo><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>m</mi><mo>∣</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>≥</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    P_{n_0,m}(x) = P[y(x)=m \mid y(0)=n_0], \quad t \geq 0
\end{align*}</annotation></semantics></math></p>
<p>which represents the probability that the population reaches a
population size equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
conditioned on the population size at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=0</annotation></semantics></math>.
Quite trivially, <span class="math inline">$P_0m=0 \hspace{1mm} \forall
m&gt;0$</span>, meaning that 0 is an absorbing state for the Markov
process. The probability generating function for this process is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>G</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><mo accent="false">∞</mo></munderover><msub><mi>P</mi><mrow><msub><mi>n</mi><mn>0</mn></msub><mi>m</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>z</mi><mi>m</mi></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    G(z,x) = \sum_{m=0}^{\infty} P_{n_0m}(x)z^m
\end{align*}</annotation></semantics></math></p>
<p>and, as shown in [12], can be rewritten as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>G</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>z</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">]</mo></mrow><msub><mi>n</mi><mn>0</mn></msub></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    G(z,x) = [1-(z-1)[(z-1)\phi(x)-\psi(x)]^{-1}]^{n_0}
\end{align*}</annotation></semantics></math></p>
<p>where the quantities
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi(x)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi(x)</annotation></semantics></math>
depends on the functional form of the individuals birth and death
rates:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>τ</mi><mo stretchy="true" form="postfix">}</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>d</mi><mi>τ</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \psi(x) = \exp \left\{ -\int_0^x (\alpha(\tau) - \beta(\tau)) d\tau \right\} \\
    \phi(x) = \int_0^x \alpha(\tau) \psi(\tau) d\tau
\end{align*}</annotation></semantics></math></p>
<p>Hence, it is possible to easily compute the expectation and the
variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y(x)</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∣</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mfrac><msub><mi>n</mi><mn>0</mn></msub><mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">Var</mtext><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mfrac><mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mn>2</mn><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>1</mn></mrow><mrow><msup><mi>ψ</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \mathbb{E}_{n_0}(x) = \mathbb{E}[y(x) \mid n_0] = \frac{n_0}{\psi(x)} \\
    \text{Var}_{n_0}(x) = n_0 \frac{\psi(x) + 2\phi(x)-1}{\psi^2(x)}
\end{align*}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="exponential-growth">Exponential growth<a class="anchor" aria-label="anchor" href="#exponential-growth"></a>
</h3>
<p>The first growth pattern we consider can be expressed through a
simple yet ubiquitous differential equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mrow><mi>d</mi><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>ρ</mi><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \frac{dy(x)}{dx} = \rho y(x)
\end{align*}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\rho \geq 0</annotation></semantics></math>
represents the growth rate. The solution of the aforementioned equation
yields</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><msup><mi>e</mi><mrow><mi>ρ</mi><mi>x</mi></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    y(x) = n_0e^{\rho x}
\end{align*}</annotation></semantics></math></p>
<p>indicating that a population starting from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>0</mn></msub><annotation encoding="application/x-tex">n_0</annotation></semantics></math>
will evolve exponentially over time with no upper bounds. In such growth
pattern, the transition rates can be written as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>α</mi><mi>n</mi></msub><mo>=</mo><mi>y</mi><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="1.0em"></mspace><msub><mi>β</mi><mi>n</mi></msub><mo>=</mo><mi>y</mi><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \alpha_n=y\alpha(x) \quad \beta_n=y\beta(x)
\end{align*}</annotation></semantics></math></p>
<p>It’s natural to observe that the birth and death rates are linear
with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
meaning that the probability of a birth (or death) happening in an
infinitesimal time-interval is proportional to the previous size of the
population. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>β</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho(x) = \alpha(x) - \beta(x)</annotation></semantics></math>
be the individual net growth rate at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
and assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho(x)</annotation></semantics></math>
is a piece-wise constant function, representing different net growth
rates for a multi-step growth process. Without loss of generality,
consider a process with a single known time-point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>1</mn></msub><annotation encoding="application/x-tex">t_1</annotation></semantics></math>
in which the net growth rate changes from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\rho_0</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\rho_1</annotation></semantics></math>;
in such case the form of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi(x)</annotation></semantics></math>
will be</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mi>x</mi><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>ϕ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">}</mo></mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>&gt;</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \phi(x) = \exp \left\{ -\rho_0 x\right\}, \quad x \leq t_1 \\
    \phi(x) = \exp \left\{ -\rho_0 t_1\right\} \exp \left\{ -\rho_1 (x-t_1)\right\}, \quad x &gt; t_1
\end{align*}</annotation></semantics></math></p>
<p>It’s trivial to see that this can be generalised to any number of
time-points, i.e. to any number of different growth rates, and that the
expected mean conditioned on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>0</mn></msub><annotation encoding="application/x-tex">n_0</annotation></semantics></math>
can be computed as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>ρ</mi><mn>0</mn></msub><mi>x</mi><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>ρ</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">}</mo></mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">{</mo><msub><mi>ρ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \mathbb{E}_{n_0}(x) = n_0 \exp \left\{ \rho_0 x\right\}, \quad x \leq t_1 \\
    \mathbb{E}_{n_0}(x) = n_0 \exp \left\{ \rho_0 t_1\right\} \exp \left\{ \rho_1 (x-t_1)\right\}, \quad x \leq t_1
\end{align*}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="logistic-growth">Logistic growth<a class="anchor" aria-label="anchor" href="#logistic-growth"></a>
</h3>
<p>The logistic model is a generalisation of the exponential one which
takes into account the possibility that the maximum population size is
constrained. In this case we define the carrying capacity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
as such upper bound, which can be caused by many environmental factors
such as the availability of resources or space. The generalised
differential equation becomes</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mrow><mi>d</mi><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mi>L</mi></mfrac><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \frac{dy(x)}{dx} = \rho \left[ 1 - \frac{y(x)}{L} y(x) \right]
\end{align*}</annotation></semantics></math></p>
<p>The second term modulates the effective growth rate affecting the
population: a bigger population size leads to a slower growth. By
letting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>→</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">L \rightarrow \infty</annotation></semantics></math>,
the logistic equation tends to the exponential one. The equation can
easily be solved by separation of variables and which yields as
solution</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mn>0</mn></msub><mi>L</mi></mrow><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>L</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><mi>ρ</mi><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    y(x) = \frac{n_0L}{n_0 + (L - n_0) \exp\{-\rho x\}}
\end{align*}</annotation></semantics></math></p>
<p>One can also merge the two terms of the differential equation and
substitute them with a time-dependent growth rate:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mrow><mi>d</mi><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>ν</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \frac{dy(x)}{dx} = \nu(x) y(x)
\end{align*}</annotation></semantics></math></p>
<p>In this case, the solution for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nu (t)</annotation></semantics></math>
is straightforward:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>ν</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>L</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>L</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>n</mi><mn>0</mn></msub><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><mi>ρ</mi><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \nu(x) = \frac{\rho (L - n_0)}{(L-n_0) + n_0 \exp \{ \rho x \}}
\end{align*}</annotation></semantics></math></p>
<p>Now, similarly as what has been done in the exponential case where
indicated the net growth rate per capita and was defined as a piece-wise
constant function,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\nu (x)</annotation></semantics></math>
once again represents the net growth rate per capita which depends on
the initial conditions, the carrying capacity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
and the functional form of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>.
Once again, we assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
to be piece-wise constant and we denote as ti its changing points.
Hence, we are modelling growth patterns in which the net growth rate
changes over the time not only depending on the population size, but
also on the value of the piece-wise constant function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\rho(t)</annotation></semantics></math>.
Now, without loss of generality let’s consider a single changing point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>1</mn></msub><annotation encoding="application/x-tex">t_1</annotation></semantics></math>
so that one can first compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\psi(x)</annotation></semantics></math>
and the the expected mean conditioned on the starting conditions
(i.e. the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>0</mn></msub><annotation encoding="application/x-tex">n_0</annotation></semantics></math>)</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mn>0</mn></msub><mi>L</mi></mrow><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>L</mi><mo>−</mo><msub><mi>n</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mn>0</mn></msub><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow></mfrac><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>≤</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mn>1</mn></msub><mi>L</mi></mrow><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>L</mi><mo>−</mo><msub><mi>n</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mrow></mfrac><mo>,</mo><mspace width="1.0em"></mspace><mi>x</mi><mo>&gt;</mo><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \mathbb{E}_{n_0}(x) = \frac{n_0L}{n_0 + (L - n_0) \exp\{-\rho_0 x\}}, \quad x \leq t_1 \\
    \mathbb{E}_{n_0}(x) = \frac{n_1L}{n_1 + (L - n_1) \exp\{-\rho_1 (x-t_1)\}}, \quad x &gt; t_1
\end{align*}</annotation></semantics></math></p>
<p>where we define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>1</mn></msub><annotation encoding="application/x-tex">n_1</annotation></semantics></math>
as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝔼</mi><msub><mi>n</mi><mn>0</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>=</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}_{n_0}(x=t_1)</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="start-of-the-process">Start of the process<a class="anchor" aria-label="anchor" href="#start-of-the-process"></a>
</h3>
<p>We discussed so far the situation in which
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">y(0)=n_0</annotation></semantics></math>
since the most common situation is that the first observation of a
growth process happens much later than the actual start of the process.
Nonetheless, one could also be interested in obtaining an estimate, or
at least an upper bound, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub><mo>=</mo><mo>min</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>∣</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">t_0 = \min\{x \mid y(x)=1\}</annotation></semantics></math>.
This can be done by simply shifting by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
the values of all the instant of times (i.e. with the change of
variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>′</mi><mo>=</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x'=x-t_0</annotation></semantics></math>).
The only modification to the model is that now
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mi>′</mi><mo>=</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y(x'=0)=1</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="population-dynamics-change-points-detection">Population dynamics change-points detection<a class="anchor" aria-label="anchor" href="#population-dynamics-change-points-detection"></a>
</h3>
<p>In general, the change-points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>
defining the intervals of time of the piece-wise functions that we
consider might not be known and, therefore, a method to infer them is
needed. The main assumption we make is that the underlying growth rates
do change sign at the breakpoints. In other words, at a given change
point, the population should change its status from “growing” to
“shrinking” or viceversa. It follows that the change-points will be
found at the locations in which the true function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y(x)</annotation></semantics></math>
describing the process will present either a minimum or a maximum, or,
equivalently, in which the first derivative
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi>′</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y'(x)</annotation></semantics></math>
will be zero. Given the intrinsic noise present in the observations, a
point might look like a maximum/minimum of the function without actually
being one. Because of this, we make use of a spline approximation to
smooth out the noise and to propose a set of candidates change-points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>t</mi><mi>i</mi></msub><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{t_i}</annotation></semantics></math>
which will be used as priors during the inference of the
breakpoints.</p>
<p>The cubic spline estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math>
is the function that minimize [13]</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">[</mo><mover><mi>y</mi><mo accent="true">̂</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><msub><mi>y</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>λ</mi><mo>∫</mo><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>″</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>d</mi><mi>x</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \frac{1}{n}\sum_{j=1}^n \left[ \hat{y}(x_n) - y_n)\right]^2 + \lambda \int \hat{y}''(x)^2 dx
\end{align*}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
is a smoothing parameter that controls the trade-off between the
“fitness” (first term) and the “roughness” (second term) of the
approximation. It’s easy to notice that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lambda = 0</annotation></semantics></math>
produces the interpolating splines whereas
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>→</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\lambda \rightarrow \infty</annotation></semantics></math>
produces a linear least squares estimate. Once the approximation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>y</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math>
is obtained, one can easily compute the points in which its first
derivative changes sign. We denote those points as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>t</mi><mi>i</mi></msub><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{t_i}</annotation></semantics></math>.
Obviously, the choice of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
affects the multiplicity of the minima/maxima that will be found.
Therefore,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
can either be user-defined or can be tuned in order to obtain a
user-defined number of change-points. Once the set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>t</mi><mi>i</mi></msub><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{t_i}</annotation></semantics></math>
have been found, we define a prior over them. For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
we choose a truncated normal distribution with the following
characteristics:</p>
<p>Moreover, the prior distributions are constrained by the fact that
the inferred change-points should be in increasing order and therefore
we enforce that their intervals do not overlap. Hence, considering
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><msub><mi>t</mi><mi>i</mi></msub><mo>=</mo><msub><mi>t</mi><mi>i</mi></msub><mo>−</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta t_i=t_i-t_{i-1}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>t</mi></msub><annotation encoding="application/x-tex">\sigma_t</annotation></semantics></math>
might change according to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>σ</mi><mi>t</mi></msub><mo>=</mo><mo>min</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>σ</mi><mi>t</mi></msub><mo>,</mo><mo>min</mo><mo stretchy="false" form="prefix">{</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>Δ</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \sigma_t = \min \{ \sigma_t, \min \{ \frac{1}{2}\Delta t_i \} \}
\end{align*}</annotation></semantics></math></p>
<p>Then, the inference is carried out in order to obtain posterior
distributions for the change points and the medians of such posteriors
can be used as “true” change points for the first task.</p>
</div>
<div class="section level3">
<h3 id="nested-growth-models-for-competing-populations">Nested growth models for competing populations<a class="anchor" aria-label="anchor" href="#nested-growth-models-for-competing-populations"></a>
</h3>
<p>A typical scenario is the one in which a tumor is treated, its mass
shrinks and it later regrows. In this case, the observed dynamics is
U-shaped. For such cases, we assume the presence of two populations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>;
the first is sensitive to the treatment, whereas the second one is
resistant to it. This means that a positive and a negative growth rates
will be exhibited by the two populations, respectively.</p>
<p>The sensitive population is assumed to be present at the start of
treatment with the initial condition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>s</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>=</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">y_s(x=0)=n_s</annotation></semantics></math>
and is governed by the differential equation</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mrow><mi>d</mi><msub><mi>y</mi><mi>s</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mo>−</mo><msub><mi>ρ</mi><mi>s</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    \frac{dy_s(x)}{dx} = -\rho_s (x)
\end{align*}</annotation></semantics></math></p>
<p>For the second population is assumed that the first resistant cell is
born at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">x=t_r</annotation></semantics></math>.
Therefore, the differential equation governing the dynamics of the
resistant population will be</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mfrac><mrow><mi>d</mi><msub><mi>y</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>=</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>ρ</mi><mi>r</mi></msub><msub><mi>y</mi><mi>r</mi></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
  \frac{dy_r(x)}{dx} = u(x - t_r) \rho_r y_r
\end{align*}</annotation></semantics></math></p>
<p>where the Heaviside function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u(x-t_r)</annotation></semantics></math>
is defined as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mn>0</mn><mo>,</mo></mtd><mtd columnalign="right" style="text-align: right"><mi>x</mi><mo>≤</mo><msub><mi>t</mi><mi>r</mi></msub></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mn>1</mn><mo>,</mo></mtd><mtd columnalign="right" style="text-align: right"><mi>x</mi><mo>&gt;</mo><msub><mi>t</mi><mi>r</mi></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  u(x-t_r) = 
   \left\{\begin{array}{lr}
       0, &amp;  x \le t_r \\
       1, &amp;  x &gt; t_r
    \end{array}\right.
\end{equation}</annotation></semantics></math></p>
<p>Trivially, the observed counts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">y(x)</annotation></semantics></math>
will be the sum of the two populations and can be obtained analytically
by integrating the two equations above and summing them. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \ge 0</annotation></semantics></math>
this gives:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mi>s</mi></msub><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><mo>−</mo><msub><mi>ρ</mi><mi>s</mi></msub><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mo>+</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>exp</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>ρ</mi><mi>r</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>t</mi><mi>r</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">}</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
    y(x) = n_s \exp\{-\rho_s x\} + u(x - t_r) \exp\{\rho_r (x - t_r)\}
\end{align*}</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="likelihood-compuation">Likelihood compuation<a class="anchor" aria-label="anchor" href="#likelihood-compuation"></a>
</h3>
<p>For all the presented models and for a given set of observations
<span class="math inline">$X =\{(x_n, y_n\)}$</span> we consider each of
them as drawn from a poisson process with parameter equal to the
expected value of the population
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝔼</mi><mi>y</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbb{E}_y(x)</annotation></semantics></math>
where the analytical form of the expected value will depend on the
considered task. This means that for a given task with parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>,
the likelihood will be computed as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>𝕃</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo>∣</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∏</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>X</mi><mo stretchy="true" form="postfix">|</mo></mrow></munderover><mtext mathvariant="normal">Poisson</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>n</mi></msub><mo>∣</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>y</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>∣</mo><mi>θ</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
\mathbb{L}(X \mid \theta) = \prod_{n=1}^{|X|} \text{Poisson}(y_n \mid \mathbb{E}[ y(x_n) \mid \theta])
\end{align*}</annotation></semantics></math></p>
</div>
</div>
<div class="section level2">
<h2 id="models-pgms">Models’ PGMs<a class="anchor" aria-label="anchor" href="#models-pgms"></a>
</h2>
<p>The probabilistic graphical models for the tree different task will
be presented and the prior distributions employed in each of them will
be described in detail.</p>
<div class="section level3">
<h3 id="task-1">Task 1<a class="anchor" aria-label="anchor" href="#task-1"></a>
</h3>
<center>
<img src="../reference/figures/pgm_1.png" width="200">
</center>
<p>Given the trajectory <span class="math inline">$X =\{(x_n,
y_n\)}$</span> of a population divided in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
time windows, the parameters of interest will be the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
growth rates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\rho_j</annotation></semantics></math>,
the instant of time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
in which the population was born and, if the population is undergoing a
logistic growth, the carrying capacity
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.</p>
<p>The priors for those values are:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>j</mi></msub><mo>∼</mo><mtext mathvariant="normal">Normal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mn>0</mn></msub><mo>∼</mo><mtext mathvariant="normal">TruncatedNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mn>100</mn><mo>,</mo><mo>−</mo><mi>∞</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>L</mi><mo>∼</mo><mtext mathvariant="normal">TruncatedNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">max</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mtext mathvariant="normal">max</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mtext mathvariant="normal">max</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>∞</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
    \rho_j \sim \text{Normal}(0,1) \\
    t_0 \sim \text{TruncatedNormal}(x_1, 100, -\infty, x_1) \\
    L \sim \text{TruncatedNormal}(\text{max}(x_n), \text{max}(x_n), \text{max}(x_n), \infty)
\end{gathered}</annotation></semantics></math><p>We choose a standard normal for the growth rates, a broad normal for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
with the constraint that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
must be smaller or equal to the time of the first observation, and a
broad normal for the carrying capacity with the constraint that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
must be greater or equal to the largest observation.</p>
</div>
<div class="section level3">
<h3 id="task-2">Task 2<a class="anchor" aria-label="anchor" href="#task-2"></a>
</h3>
<center>
<img src="../reference/figures/pgm_2.png" width="200">
</center>
<p>Given the trajectory <span class="math inline">$X =\{(x_n,
y_n\)}$</span> of a population, the parameters of interest will be the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">J-1</annotation></semantics></math>
change points, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">J-1</annotation></semantics></math>
is either given by the user or is the results of the choice of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>
parameter in the spline approximation.</p>
<p>The priors for those values are:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mi>j</mi></msub><mo>∼</mo><mtext mathvariant="normal">TruncatedNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><mo>,</mo><msub><mi>σ</mi><mi>t</mi></msub><mo>,</mo><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><mo>−</mo><msub><mi>σ</mi><mi>t</mi></msub><mo>,</mo><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><mo>+</mo><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
    t_j \sim \text{TruncatedNormal}(\hat{t_j},\sigma_t, \hat{t_j} - \sigma_t, \hat{t_j} + \sigma_t) \\
\end{gathered}</annotation></semantics></math><p>Essentially, for each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{t_j}</annotation></semantics></math>
proposed by the spline approximation we choose a flat normal
distribution constrained in the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><mo>−</mo><msub><mi>σ</mi><mi>t</mi></msub><mo>,</mo><mover><msub><mi>t</mi><mi>j</mi></msub><mo accent="true">̂</mo></mover><mo>+</mo><msub><mi>σ</mi><mi>t</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\hat{t_j}-\sigma_t, \hat{t_j} + \sigma_t]</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="task-3">Task 3<a class="anchor" aria-label="anchor" href="#task-3"></a>
</h3>
<center>
<img src="../reference/figures/pgm_3.png" width="200">
</center>
<p>Given the trajectory <span class="math inline">$X =\{(x_n,
y_n\)}$</span> where a resistant and a sensitive population are assumed
to co-exist, the parameters of interest will the two growth rates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>s</mi></msub><annotation encoding="application/x-tex">\rho_s</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>r</mi></msub><annotation encoding="application/x-tex">\rho_r</annotation></semantics></math>,
the size of the sensitive population
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>s</mi></msub><annotation encoding="application/x-tex">n_s</annotation></semantics></math>
at the instant of time of the first observation and the instant of time
in which the resistant population is born
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>r</mi></msub><annotation encoding="application/x-tex">t_r</annotation></semantics></math>.</p>
<p>The priors for those values are:</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>s</mi></msub><mo>∼</mo><mtext mathvariant="normal">HalfNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ρ</mi><mi>r</mi></msub><mo>∼</mo><mtext mathvariant="normal">HalfNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>n</mi><mi>s</mi></msub><mo>∼</mo><mtext mathvariant="normal">TruncatedNormal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msub><mi>y</mi><mn>1</mn></msub><mn>2</mn></mfrac><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mn>1</mn><mo>,</mo><mn>1.1</mn><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>t</mi><mi>r</mi></msub><mo>∼</mo><mtext mathvariant="normal">Normal</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mn>100</mn><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
    \rho_s \sim \text{HalfNormal}(0,1) \\
    \rho_r \sim \text{HalfNormal}(0,1) \\
    n_s \sim \text{TruncatedNormal}(\frac{y_1}{2}, y_1, 1, 1.1 y_1) \\
    t_r \sim \text{Normal}(x_1, 100)
\end{gathered}</annotation></semantics></math><p>Essentially, we choose a standard normal distribution for the two
growth rates, a very broad normal for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>s</mi></msub><annotation encoding="application/x-tex">n_s</annotation></semantics></math>
with the constraint that if at the beginning the resistant population is
not born yet, the maximum error we are committing is 10%, and a very
flat normal distribution centered on the beginning of the process for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>r</mi></msub><annotation encoding="application/x-tex">t_r</annotation></semantics></math>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Giovanni Santacatterina.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
